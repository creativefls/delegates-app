// const { assets } = global.serviceWorkerOption
import localForage from 'localforage'
const CACHE = 'flsguide-cache-v0.13-' + BUILDSTAMP 
const strategies = {
  NETWORK_FALLING_BACK_TO_CACHE: 'net2cache',
  CACHE_FALLING_BACK_TO_NETWORK: 'cache2net',
  NETWORK_ONLY: 'netonly',
}
const FRONTEND = /((https\:\/\/fls\.nurulirfan\.com)|(http:\/\/localhost:3000))(?!.*sockjs-node)./
const API_ASSETS = /(?=.*\/api\/static\/)(?!.*hires).*/
const CONTENT = /\/api\/((?!static))/
const TEST = /\/test/
const origins = [
  'https://apifls.nurulirfan.com',
  'http://localhost:8080',
  'http://localhost:3000',
  'http://localhost:3001',
  self.location.origin,
]

let assetsToCache = [
  ...serviceWorkerOption.assets,
  '/announcement',
  '/home',
  '/'
]
//exclude index and manifest from autogenerated
assetsToCache = assetsToCache.filter(asset => { 
  return ['/index.html', '/manifest.json'].indexOf(asset) < 0 
})

self.addEventListener('install', function (event) {
  console.log('[SW] The service worker is being installed.');
  console.log('[SW] Assets to be cached:', assetsToCache);
  event.waitUntil(precache().then(function () {
    console.log('[SW] all files are cached. Installed.');
    // return self.skipWaiting();
  }));
});

//allow sw to control of current page
self.addEventListener('activate', function (event) {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      var toBeDeleted = cacheNames.filter(cache => cache !== CACHE)
      return Promise.all(toBeDeleted.map(cache => {
        return caches.delete(cache)
      })).then(() => {
        console.log('[SW] Claiming clients for current page');
        return self.clients.claim();
      })
    })
  )
});

self.addEventListener('fetch', function (event) {
  var strat = whichStrategies(event)
  console.log("[SW]", event.request.url, ':', strat);
  switch (strat) {
    case strategies.CACHE_FALLING_BACK_TO_NETWORK:
      event.respondWith(cacheToNetwork(event))
      break
    case strategies.NETWORK_FALLING_BACK_TO_CACHE:
      event.respondWith(networkToCache(event))
      break
    default:
      event.respondWith(netOnly(event))
      break
  }
});

function cacheToNetwork (event) {
  return caches.match(event.request)
  .then(response => {
    return response || fetch(event.request);
  })
}

function networkToCache (event) {
  return fetch(event.request, {cache: 'no-cache'}) // tell browser not to get from cache
  .then(nResponse => {
    return caches.open(CACHE).then(function (cache) {
      console.log("[SW]", event.request.url, 'terambil dari network');
      if (nResponse.status >= 200 || nResponse.status < 300) {
        cache.put(event.request, nResponse.clone())
      }
      return nResponse
    })
  })
  .catch(() => {
    return caches.match(event.request)
    .then(response => {
      if (!response) throw 'not found in cache'
      console.log("[SW]", event.request.url, 'terambil dari cache');
      return response
    })
    .catch(error => {
      console.log("[SW]", event.request.url, 'terambil dari dummy');
      return caches.match('/images/logo.png')
    })
  })
}

function netOnly (event) {
  return fetch(event.request);
}

self.addEventListener('push', function (event) {
  localForage.getItem('notif').then(item => {
    if (item) item += 1
    else item = 1
    localForage.setItem('notif', item)
  })
  
  console.log('[SW] New notification!');
  const payload = event.data ? event.data.json() : 'tests';
  event.waitUntil(
    self.registration.showNotification(payload.title, {
      icon: 'images/logo.png',
      body: payload.content,
      data: payload
    })
  )
})

self.addEventListener('notificationclick', function (event) {
  console.log('[SW] Notification clicked');
  if (Notification.prototype.hasOwnProperty('data')) {
    // console.log('using data', event.notification);
    var url = event.notification.data.url
    event.waitUntil(clients.openWindow(url))
  }
  event.notification.close();
})

function precache() {
  return caches.open(CACHE).then(function (cache) {
    return cache.addAll(assetsToCache);
  });
}

function whichStrategies (event) {
  var request = event.request.clone()
  var url = new URL(request.url)

  var isGET = request.method === 'GET'
  var isOriginAllowed = origins.indexOf(url.origin) >= 0
  
  if(isGET && isOriginAllowed) {
    if (TEST.test(url.href)) {
      return strategies.NETWORK_ONLY
    }
    else if (FRONTEND.test(url.href)) {
      return strategies.CACHE_FALLING_BACK_TO_NETWORK
    }
    else if (API_ASSETS.test(url.pathname)) { // use network first
      return strategies.NETWORK_FALLING_BACK_TO_CACHE
    }
    else {
      return strategies.NETWORK_ONLY
    }
  }
  else {
    return strategies.NETWORK_ONLY
  }
}